/**
 * @fileoverview A simple organizer for ordering hooks.
 * @author Romullo @hiukky
 */
'use strict';
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_GROUPS = void 0;
exports.DEFAULT_GROUPS = [
    'useReducer',
    'useContext',
    'useState',
    'useRef',
    'useDispatch',
    'useCallback',
    'useEffect',
];
module.exports = {
    meta: {
        docs: {
            description: 'A simple organizer for ordering hooks.',
            category: 'Non-matching declaration order.',
            url: 'https://github.com/hiukky/eslint-plugin-hooks/blob/main/docs/rules/sort.md',
            recommended: false,
        },
        fixable: undefined,
        schema: [
            {
                type: 'object',
                properties: {
                    groups: {
                        type: 'array',
                    },
                },
            },
        ],
    },
    create: function (ctx) {
        var options = ctx.options[0];
        var groups = (options === null || options === void 0 ? void 0 : options.groups) || exports.DEFAULT_GROUPS;
        return {
            Program: function (_a) {
                var body = _a.body;
                body
                    .filter(function (_a) {
                    var type = _a.type;
                    return [
                        'FunctionDeclaration',
                        'VariableDeclaration',
                        'ExportNamedDeclaration',
                        'ExportDefaultDeclaration',
                    ].includes(type);
                })
                    .map(function (node) {
                    var _a, _b, _c, _d;
                    var declarations = node;
                    var isExportableDeclaration = function () {
                        return ['ExportNamedDeclaration', 'ExportDefaultDeclaration'].includes(node.type);
                    };
                    if (isExportableDeclaration()) {
                        declarations =
                            ((_b = (_a = node['declaration']) === null || _a === void 0 ? void 0 : _a['declarations']) === null || _b === void 0 ? void 0 : _b[0]['init']) ||
                                node['declaration'];
                    }
                    else {
                        declarations = ((_c = node['declarations']) === null || _c === void 0 ? void 0 : _c[0]['init']) || node;
                    }
                    return (_d = declarations === null || declarations === void 0 ? void 0 : declarations['body']) === null || _d === void 0 ? void 0 : _d['body'];
                })
                    .filter(Boolean)
                    .forEach(function (declarations) {
                    var _a;
                    var nodes = [];
                    (_a = declarations.forEach) === null || _a === void 0 ? void 0 : _a.call(declarations, function (node) {
                        if (node['type'] === 'ExpressionStatement') {
                            nodes.push(node['expression']);
                        }
                        if (node['type'] === 'VariableDeclaration') {
                            nodes.push.apply(nodes, node['declarations']);
                        }
                    });
                    var hooks = nodes === null || nodes === void 0 ? void 0 : nodes.map(function (_a) {
                        var type = _a.type, callee = _a.callee, init = _a.init;
                        return (type === 'CallExpression'
                            ? [type, callee]
                            : type === 'VariableDeclarator'
                                ? [type, init]
                                : []);
                    }).filter(function (node) { return node.length === 2; }).map(function (_a) {
                        var _b;
                        var type = _a[0], declaration = _a[1];
                        switch (type) {
                            case 'MemberExpression':
                                return declaration.property;
                            case 'CallExpression':
                                return declaration.type === 'MemberExpression'
                                    ? declaration.property
                                    : declaration.callee || declaration;
                            case 'VariableDeclarator':
                            default:
                                return ((_b = declaration === null || declaration === void 0 ? void 0 : declaration.callee) === null || _b === void 0 ? void 0 : _b.property) || (declaration === null || declaration === void 0 ? void 0 : declaration.callee);
                        }
                    }).filter(Boolean).filter(function (hook) {
                        var _a;
                        return ((_a = hook.name) === null || _a === void 0 ? void 0 : _a.slice(0, 3)) === 'use' &&
                            groups.includes(hook.name);
                    });
                    var correctOrdering = __spreadArray([], hooks, true).sort(function (a, b) { return groups.indexOf(a.name) - groups.indexOf(b.name); });
                    hooks.forEach(function (hook, idx) {
                        var noMatching = function () {
                            return correctOrdering.length > 1 &&
                                correctOrdering[idx].name !== hook.name;
                        };
                        if (noMatching()) {
                            ctx.report(hook, "Non-matching declaration order. ".concat(hook.name, " comes ").concat(!idx ? 'after' : 'before', " ").concat(correctOrdering[idx].name, "."));
                        }
                    });
                });
            },
        };
    },
};
